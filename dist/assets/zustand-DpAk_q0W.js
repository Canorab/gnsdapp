var _={BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const E=u=>(o,i,n)=>{const l=n.subscribe;return n.subscribe=(f,d,c)=>{let a=f;if(d){const h=(c==null?void 0:c.equalityFn)||Object.is;let m=f(n.getState());a=y=>{const S=f(y);if(!h(m,S)){const b=m;d(m=S,b)}},c!=null&&c.fireImmediately&&d(m,m)}return l(a)},u(o,i,n)},F=E;function R(u,o){let i;try{i=u()}catch{return}return{getItem:l=>{var e;const f=c=>c===null?null:JSON.parse(c,o==null?void 0:o.reviver),d=(e=i.getItem(l))!=null?e:null;return d instanceof Promise?d.then(f):f(d)},setItem:(l,e)=>i.setItem(l,JSON.stringify(e,o==null?void 0:o.replacer)),removeItem:l=>i.removeItem(l)}}const p=u=>o=>{try{const i=u(o);return i instanceof Promise?i:{then(n){return p(n)(i)},catch(n){return this}}}catch(i){return{then(n){return this},catch(n){return p(n)(i)}}}},w=(u,o)=>(i,n,l)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:r=>r,version:0,merge:(r,v)=>({...v,...r}),...o},f=!1;const d=new Set,c=new Set;let a;try{a=e.getStorage()}catch{}if(!a)return u((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),i(...r)},n,l);const h=p(e.serialize),m=()=>{const r=e.partialize({...n()});let v;const t=h({state:r,version:e.version}).then(g=>a.setItem(e.name,g)).catch(g=>{v=g});if(v)throw v;return t},y=l.setState;l.setState=(r,v)=>{y(r,v),m()};const S=u((...r)=>{i(...r),m()},n,l);let b;const s=()=>{var r;if(!a)return;f=!1,d.forEach(t=>t(n()));const v=((r=e.onRehydrateStorage)==null?void 0:r.call(e,n()))||void 0;return p(a.getItem.bind(a))(e.name).then(t=>{if(t)return e.deserialize(t)}).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var g;return b=e.merge(t,(g=n())!=null?g:S),i(b,!0),m()}).then(()=>{v==null||v(b,void 0),f=!0,c.forEach(t=>t(b))}).catch(t=>{v==null||v(void 0,t)})};return l.persist={setOptions:r=>{e={...e,...r},r.getStorage&&(a=r.getStorage())},clearStorage:()=>{a==null||a.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>s(),hasHydrated:()=>f,onHydrate:r=>(d.add(r),()=>{d.delete(r)}),onFinishHydration:r=>(c.add(r),()=>{c.delete(r)})},s(),b||S},H=(u,o)=>(i,n,l)=>{let e={storage:R(()=>localStorage),partialize:s=>s,version:0,merge:(s,r)=>({...r,...s}),...o},f=!1;const d=new Set,c=new Set;let a=e.storage;if(!a)return u((...s)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),i(...s)},n,l);const h=()=>{const s=e.partialize({...n()});return a.setItem(e.name,{state:s,version:e.version})},m=l.setState;l.setState=(s,r)=>{m(s,r),h()};const y=u((...s)=>{i(...s),h()},n,l);let S;const b=()=>{var s,r;if(!a)return;f=!1,d.forEach(t=>{var g;return t((g=n())!=null?g:y)});const v=((r=e.onRehydrateStorage)==null?void 0:r.call(e,(s=n())!=null?s:y))||void 0;return p(a.getItem.bind(a))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var g;return S=e.merge(t,(g=n())!=null?g:y),i(S,!0),h()}).then(()=>{v==null||v(S,void 0),S=n(),f=!0,c.forEach(t=>t(S))}).catch(t=>{v==null||v(void 0,t)})};return l.persist={setOptions:s=>{e={...e,...s},s.storage&&(a=s.storage)},clearStorage:()=>{a==null||a.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>b(),hasHydrated:()=>f,onHydrate:s=>(d.add(s),()=>{d.delete(s)}),onFinishHydration:s=>(c.add(s),()=>{c.delete(s)})},e.skipHydration||b(),S||y},D=(u,o)=>"getStorage"in o||"serialize"in o||"deserialize"in o?((_?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),w(u,o)):H(u,o),P=D;var O={BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const I=u=>{let o;const i=new Set,n=(c,a)=>{const h=typeof c=="function"?c(o):c;if(!Object.is(h,o)){const m=o;o=a??typeof h!="object"?h:Object.assign({},o,h),i.forEach(y=>y(o,m))}},l=()=>o,d={setState:n,getState:l,subscribe:c=>(i.add(c),()=>i.delete(c)),destroy:()=>{(O?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),i.clear()}};return o=u(n,l,d),d},j=u=>u?I(u):I;export{j as c,P as p,F as s};
