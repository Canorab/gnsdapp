function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/@coinbase-NHaBArST.js","assets/@babel-BTUyE5mg.js","assets/bn.js-DJU_YgZd.js","assets/@stablelib-vyXRoFjD.js","assets/eventemitter3-B2QLvKQr.js","assets/sha.js-NpPo8kvZ.js","assets/inherits-BlmhoU4v.js","assets/safe-buffer-uF9_Nnb9.js","assets/buffer-EBb79ogF.js","assets/base64-js-D0UyVEDn.js","assets/ieee754-DSYfm7We.js","assets/preact-C95QSVJ5.js","assets/keccak-hPcv27KM.js","assets/readable-stream-30dAIq04.js","assets/events-BEk73iUA.js","assets/util-deprecate-CSw-W21V.js","assets/string_decoder-CLRiUdIC.js","assets/eth-block-tracker-_wWlT23E.js","assets/json-rpc-random-id-DmWAYPg7.js","assets/@metamask-D5jLp4R4.js","assets/superstruct-D_tVzfND.js","assets/debug-Kk5lNELL.js","assets/ms-CzQ2E3wO.js","assets/semver-MVTUpC9i.js","assets/eth-json-rpc-filters-CNVWR0wF.js","assets/eth-query-CTJIkvOv.js","assets/xtend-CeaPpq3n.js","assets/json-rpc-engine-bI79XHen.js","assets/eth-rpc-errors-C5LhrPve.js","assets/fast-safe-stringify-Bs-GRd1a.js","assets/async-mutex-C8K7s2QC.js","assets/tslib-iwng_IcJ.js","assets/@walletconnect-DbPiUmHX.js","assets/multiformats-DSKVg-N-.js","assets/detect-browser-ZFJ04nK6.js","assets/query-string-SCOpAa9y.js","assets/strict-uri-encode-DdzwWRIL.js","assets/decode-uri-component-CROxjmim.js","assets/split-on-first-BNP3K2Fc.js","assets/filter-obj-DG2z_hf8.js","assets/uint8arrays-BSAB2j_x.js","assets/unstorage-I5IaDmqs.js","assets/destr-CVtkxrq9.js","assets/idb-keyval-nibyPLVP.js","assets/pino-DvZ7D6Zk.js","assets/quick-format-unescaped-Dys6CG9o.js","assets/lodash.isequal-g7gT64gE.js","assets/isomorphic-unfetch-CsQpLwNz.js","assets/unfetch-BG55bwD0.js","assets/cross-fetch-DHrHFfeo.js","assets/@lit-DjZwrzog.js","assets/lit-html-DfFMVDgK.js","assets/lit-element-Cx71in3k.js","assets/valtio-D-UtsqsE.js","assets/proxy-compare-DDw08AJZ.js","assets/react-eX7k_oyb.js","assets/qrcode-CGiDONbL.js","assets/encode-utf8-Cn5aGd7v.js","assets/dijkstrajs-D_NXgYpA.js","assets/motion-DTBDFaPB.js","assets/@motionone-CzvwtEH0.js","assets/zustand-BxVvYF66.js","assets/viem-DO_zHWKk.js","assets/mipd-CIcDX0W7.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
import{c as E,s as wt,p as yt}from"./zustand-BxVvYF66.js";import{g as M,U as A,R as G,w as mt,a as bt,S as R,n as D,c as st,p as vt,b as Ct,e as it,d as It,m as St,r as _t,C as ct,h as ot,t as At,f as rt,i as jt,j as kt,k as Mt,l as Ut,s as $t,o as qt,q as Nt,u as Ot,v as Rt}from"./viem-DO_zHWKk.js";import{E as Dt}from"./eventemitter3-B2QLvKQr.js";import{c as xt}from"./mipd-CIcDX0W7.js";const Tt="modulepreload",Lt=function(e){return"/"+e},Y={},at=function(i,t,a){let u=Promise.resolve();if(t&&t.length>0){const o=document.getElementsByTagName("link"),n=document.querySelector("meta[property=csp-nonce]"),r=(n==null?void 0:n.nonce)||(n==null?void 0:n.getAttribute("nonce"));u=Promise.all(t.map(s=>{if(s=Lt(s),s in Y)return;Y[s]=!0;const c=s.endsWith(".css"),l=c?'[rel="stylesheet"]':"";if(!!a)for(let w=o.length-1;w>=0;w--){const y=o[w];if(y.href===s&&(!c||y.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${s}"]${l}`))return;const h=document.createElement("link");if(h.rel=c?"stylesheet":Tt,c||(h.as="script",h.crossOrigin=""),h.href=s,r&&h.setAttribute("nonce",r),document.head.appendChild(h),c)return new Promise((w,y)=>{h.addEventListener("load",w),h.addEventListener("error",()=>y(new Error(`Unable to preload CSS for ${s}`)))})}))}return u.then(()=>i()).catch(o=>{const n=new Event("vite:preloadError",{cancelable:!0});if(n.payload=o,window.dispatchEvent(n),!n.defaultPrevented)throw o})};var L=function(e,i,t,a){if(t==="a"&&!a)throw new TypeError("Private accessor was defined without a getter");if(typeof i=="function"?e!==i||!a:!i.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?a:t==="a"?a.call(e):a?a.value:i.get(e)},q;class Wt{constructor(i){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:i}),q.set(this,new Dt)}on(i,t){L(this,q,"f").on(i,t)}once(i,t){L(this,q,"f").once(i,t)}off(i,t){L(this,q,"f").off(i,t)}emit(i,...t){const a=t[0];L(this,q,"f").emit(i,{uid:this.uid,...a})}listenerCount(i){return L(this,q,"f").listenerCount(i)}}q=new WeakMap;function Pt(e){return new Wt(e)}function zt(e,i){return JSON.parse(e,(t,a)=>{let u=a;return(u==null?void 0:u.__type)==="bigint"&&(u=BigInt(u.value)),(u==null?void 0:u.__type)==="Map"&&(u=new Map(u.value)),(i==null?void 0:i(t,u))??u})}function tt(e,i){return e.slice(0,i).join(".")||"."}function et(e,i){const{length:t}=e;for(let a=0;a<t;++a)if(e[a]===i)return a+1;return 0}function Ft(e,i){const t=typeof e=="function",a=typeof i=="function",u=[],o=[];return function(r,s){if(typeof s=="object")if(u.length){const c=et(u,this);c===0?u[u.length]=this:(u.splice(c),o.splice(c)),o[o.length]=r;const l=et(u,s);if(l!==0)return a?i.call(this,r,s,tt(o,l)):`[ref=${tt(o,l)}]`}else u[0]=s,o[0]=r;return t?e.call(this,r,s):s}}function Bt(e,i,t,a){return JSON.stringify(e,Ft((u,o)=>{let n=o;return typeof n=="bigint"&&(n={__type:"bigint",value:o.toString()}),n instanceof Map&&(n={__type:"Map",value:Array.from(o.entries())}),(i==null?void 0:i(u,n))??n},a),t??void 0)}function Et(e){const{deserialize:i=zt,key:t="wagmi",serialize:a=Bt,storage:u=ut}=e;function o(n){return n instanceof Promise?n.then(r=>r).catch(()=>null):n}return{...u,key:t,async getItem(n,r){const s=u.getItem(`${t}.${n}`),c=await o(s);return c?i(c)??null:r??null},async setItem(n,r){const s=`${t}.${n}`;r===null?await o(u.removeItem(s)):await o(u.setItem(s,a(r)))},async removeItem(n){await o(u.removeItem(`${t}.${n}`))}}}const ut={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};function re(e){return e}const z="2.9.6",Gt=()=>`@wagmi/core@${z}`;var lt=function(e,i,t,a){if(t==="a"&&!a)throw new TypeError("Private accessor was defined without a getter");if(typeof i=="function"?e!==i||!a:!i.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?a:t==="a"?a.call(e):a?a.value:i.get(e)},B,dt;class U extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return Gt()}constructor(i,t={}){var o;super(),B.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const a=t.cause instanceof U?t.cause.details:(o=t.cause)!=null&&o.message?t.cause.message:t.details,u=t.cause instanceof U&&t.cause.docsPath||t.docsPath;this.message=[i||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...u?[`Docs: ${this.docsBaseUrl}${u}.html${t.docsSlug?`#${t.docsSlug}`:""}`]:[],...a?[`Details: ${a}`]:[],`Version: ${this.version}`].join(`
`),t.cause&&(this.cause=t.cause),this.details=a,this.docsPath=u,this.metaMessages=t.metaMessages,this.shortMessage=i}walk(i){return lt(this,B,"m",dt).call(this,this,i)}}B=new WeakSet,dt=function e(i,t){return t!=null&&t(i)?i:i.cause?lt(this,B,"m",e).call(this,i.cause,t):i};class x extends U{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}}class Kt extends U{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}}class Vt extends U{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}}class Ht extends U{constructor({address:i,connector:t}){super(`Account "${i}" not found for connector "${t.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}}class N extends U{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}class Jt extends U{constructor({connector:i}){super(`"${i.name}" does not support programmatic chain switching.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SwitchChainNotSupportedError"})}}const Qt=/(rabby|trustwallet)/,Zt={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(e){return e!=null&&e.coinbaseWalletExtension?e.coinbaseWalletExtension:F(e,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(e){return F(e,i=>{if(!i.isMetaMask||i.isBraveWallet&&!i._events&&!i._state)return!1;const t=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRabby","isTokenPocket","isTokenary","isZerion"];for(const a of t)if(i[a])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(e){var i,t;return(i=e==null?void 0:e.phantom)!=null&&i.ethereum?(t=e.phantom)==null?void 0:t.ethereum:F(e,"isPhantom")}}};J.type="injected";function J(e={}){const{shimDisconnect:i=!0,unstable_shimAsyncInject:t}=e;function a(){const s=e.target;if(typeof s=="function"){const c=s();if(c)return c}return typeof s=="object"?s:typeof s=="string"?{...Zt[s]??{id:s,name:`${s[0].toUpperCase()}${s.slice(1)}`,provider:`is${s[0].toUpperCase()}${s.slice(1)}`}}:{id:"injected",name:"Injected",provider(c){return c==null?void 0:c.ethereum}}}let u,o,n,r;return s=>({get icon(){return a().icon},get id(){return a().id},get name(){return a().name},get supportsSimulation(){return Qt.test(this.id.toLowerCase())},type:J.type,async setup(){const c=await this.getProvider();c&&e.target&&(n||(n=this.onConnect.bind(this),c.on("connect",n)),u||(u=this.onAccountsChanged.bind(this),c.on("accountsChanged",u)))},async connect({chainId:c,isReconnecting:l}={}){var w,y,b,m,v,_;const d=await this.getProvider();if(!d)throw new N;let h=[];if(l)h=await this.getAccounts().catch(()=>[]);else if(i)try{h=(m=(b=(y=(w=(await d.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0])==null?void 0:w.caveats)==null?void 0:y[0])==null?void 0:b.value)==null?void 0:m.map(f=>M(f))}catch(I){const f=I;if(f.code===A.code)throw new A(f);if(f.code===G.code)throw f}try{!(h!=null&&h.length)&&!l&&(h=(await d.request({method:"eth_requestAccounts"})).map(g=>M(g))),n&&(d.removeListener("connect",n),n=void 0),u||(u=this.onAccountsChanged.bind(this),d.on("accountsChanged",u)),o||(o=this.onChainChanged.bind(this),d.on("chainChanged",o)),r||(r=this.onDisconnect.bind(this),d.on("disconnect",r));let I=await this.getChainId();if(c&&I!==c){const f=await this.switchChain({chainId:c}).catch(g=>{if(g.code===A.code)throw g;return{id:I}});I=(f==null?void 0:f.id)??I}return i&&await((v=s.storage)==null?void 0:v.removeItem(`${this.id}.disconnected`)),e.target||await((_=s.storage)==null?void 0:_.setItem("injected.connected",!0)),{accounts:h,chainId:I}}catch(I){const f=I;throw f.code===A.code?new A(f):f.code===G.code?new G(f):f}},async disconnect(){var l,d;const c=await this.getProvider();if(!c)throw new N;o&&(c.removeListener("chainChanged",o),o=void 0),r&&(c.removeListener("disconnect",r),r=void 0),n||(n=this.onConnect.bind(this),c.on("connect",n));try{await c.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}i&&await((l=s.storage)==null?void 0:l.setItem(`${this.id}.disconnected`,!0)),e.target||await((d=s.storage)==null?void 0:d.removeItem("injected.connected"))},async getAccounts(){const c=await this.getProvider();if(!c)throw new N;return(await c.request({method:"eth_accounts"})).map(d=>M(d))},async getChainId(){const c=await this.getProvider();if(!c)throw new N;const l=await c.request({method:"eth_chainId"});return Number(l)},async getProvider(){if(typeof window>"u")return;let c;const l=a();return typeof l.provider=="function"?c=l.provider(window):typeof l.provider=="string"?c=F(window,l.provider):c=l.provider,c&&!c.removeListener&&("off"in c&&typeof c.off=="function"?c.removeListener=c.off:c.removeListener=()=>{}),c},async isAuthorized(){var c,l;try{if(i&&await((c=s.storage)==null?void 0:c.getItem(`${this.id}.disconnected`))||!e.target&&!await((l=s.storage)==null?void 0:l.getItem("injected.connected")))return!1;if(!await this.getProvider()){if(t!==void 0&&t!==!1){const y=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",y),!!await this.getProvider()),b=typeof t=="number"?t:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(v=>window.addEventListener("ethereum#initialized",()=>v(y()),{once:!0}))]:[],new Promise(v=>setTimeout(()=>v(y()),b))]))return!0}throw new N}return!!(await mt(()=>bt(()=>this.getAccounts(),{timeout:100}))).length}catch{return!1}},async switchChain({addEthereumChainParameter:c,chainId:l}){var w,y,b,m;const d=await this.getProvider();if(!d)throw new N;const h=s.chains.find(v=>v.id===l);if(!h)throw new R(new x);try{return await Promise.all([d.request({method:"wallet_switchEthereumChain",params:[{chainId:D(l)}]}).then(async()=>{await this.getChainId()===l&&s.emitter.emit("change",{chainId:l})}),new Promise(v=>s.emitter.once("change",({chainId:_})=>{_===l&&v()}))]),h}catch(v){const _=v;if(_.code===4902||((y=(w=_==null?void 0:_.data)==null?void 0:w.originalError)==null?void 0:y.code)===4902)try{const{default:I,...f}=h.blockExplorers??{};let g;c!=null&&c.blockExplorerUrls?g=c.blockExplorerUrls:I&&(g=[I.url,...Object.values(f).map(T=>T.url)]);let p;(b=c==null?void 0:c.rpcUrls)!=null&&b.length?p=c.rpcUrls:p=[((m=h.rpcUrls.default)==null?void 0:m.http[0])??""];const C={blockExplorerUrls:g,chainId:D(l),chainName:(c==null?void 0:c.chainName)??h.name,iconUrls:c==null?void 0:c.iconUrls,nativeCurrency:(c==null?void 0:c.nativeCurrency)??h.nativeCurrency,rpcUrls:p};if(await d.request({method:"wallet_addEthereumChain",params:[C]}),await this.getChainId()!==l)throw new A(new Error("User rejected switch after adding network."));return h}catch(I){throw new A(I)}throw _.code===A.code?new A(_):new R(_)}},async onAccountsChanged(c){var l;if(c.length===0)this.onDisconnect();else if(s.emitter.listenerCount("connect")){const d=(await this.getChainId()).toString();this.onConnect({chainId:d}),i&&await((l=s.storage)==null?void 0:l.removeItem(`${this.id}.disconnected`))}else s.emitter.emit("change",{accounts:c.map(d=>M(d))})},onChainChanged(c){const l=Number(c);s.emitter.emit("change",{chainId:l})},async onConnect(c){const l=await this.getAccounts();if(l.length===0)return;const d=Number(c.chainId);s.emitter.emit("connect",{accounts:l,chainId:d});const h=await this.getProvider();h&&(n&&(h.removeListener("connect",n),n=void 0),u||(u=this.onAccountsChanged.bind(this),h.on("accountsChanged",u)),o||(o=this.onChainChanged.bind(this),h.on("chainChanged",o)),r||(r=this.onDisconnect.bind(this),h.on("disconnect",r)))},async onDisconnect(c){const l=await this.getProvider();c&&c.code===1013&&l&&(await this.getAccounts()).length||(s.emitter.emit("disconnect"),l&&(o&&(l.removeListener("chainChanged",o),o=void 0),r&&(l.removeListener("disconnect",r),r=void 0),n||(n=this.onConnect.bind(this),l.on("connect",n))))}})}function F(e,i){function t(u){return typeof i=="function"?i(u):typeof i=="string"?u[i]:!0}const a=e.ethereum;if(a!=null&&a.providers)return a.providers.find(u=>t(u));if(a&&t(a))return a}const V=256;let W=V,P;function Xt(e=11){if(!P||W+e>V*2){P="",W=0;for(let i=0;i<V;i++)P+=(256+Math.random()*256|0).toString(16).substring(1)}return P.substring(W,W+++e)}function ae(e){const{multiInjectedProviderDiscovery:i=!0,storage:t=Et({storage:typeof window<"u"&&window.localStorage?window.localStorage:ut}),syncConnectedChain:a=!0,ssr:u,...o}=e,n=typeof window<"u"&&i?xt():void 0,r=E(()=>o.chains),s=E(()=>[...o.connectors??[],...u?[]:(n==null?void 0:n.getProviders().map(l))??[]].map(c));function c(f){var C;const g=Pt(Xt()),p={...f({emitter:g,chains:r.getState(),storage:t}),emitter:g,uid:g.uid};return g.on("connect",_),(C=p.setup)==null||C.call(p),p}function l(f){const{info:g}=f,p=f.provider;return J({target:{...g,id:g.rdns,provider:p}})}const d=new Map;function h(f={}){const g=f.chainId??m.getState().chainId,p=r.getState().find(S=>S.id===g);if(f.chainId&&!p)throw new x;{const S=d.get(m.getState().chainId);if(S&&!p)return S;if(!p)throw new x}{const S=d.get(g);if(S)return S}let C;if(o.client)C=o.client({chain:p});else{const S=p.id,T=r.getState().map(k=>k.id),$={},X=Object.entries(o);for(const[k,O]of X)if(!(k==="chains"||k==="client"||k==="connectors"||k==="transports"))if(typeof O=="object")if(S in O)$[k]=O[S];else{if(T.some(gt=>gt in O))continue;$[k]=O}else $[k]=O;C=st({...$,chain:p,batch:$.batch??{multicall:!0},transport:k=>o.transports[S]({...k,connectors:s})})}return d.set(g,C),C}function w(){return{chainId:r.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let y;const b="0.0.0-canary-";z.startsWith(b)?y=parseInt(z.replace(b,"")):y=parseInt(z.split(".")[0]??"0");const m=E(wt(t?yt(w,{migrate(f,g){if(g===y)return f;const p=w(),C=f&&typeof f=="object"&&"chainId"in f&&typeof f.chainId=="number"?f.chainId:p.chainId;return{...p,chainId:C}},name:"store",partialize(f){return{connections:{__type:"Map",value:Array.from(f.connections.entries()).map(([g,p])=>{const{id:C,name:S,type:T,uid:$}=p.connector;return[g,{...p,connector:{id:C,name:S,type:T,uid:$}}]})},chainId:f.chainId,current:f.current}},skipHydration:u,storage:t,version:y}):w));a&&m.subscribe(({connections:f,current:g})=>{var p;return g?(p=f.get(g))==null?void 0:p.chainId:void 0},f=>{if(r.getState().some(p=>p.id===f))return m.setState(p=>({...p,chainId:f??p.chainId}))}),n==null||n.subscribe(f=>{const g=new Map;for(const C of s.getState())g.set(C.id,!0);const p=[];for(const C of f){const S=c(l(C));g.has(S.id)||p.push(S)}t&&!m.persist.hasHydrated()||s.setState(C=>[...C,...p],!0)});function v(f){m.setState(g=>{const p=g.connections.get(f.uid);return p?{...g,connections:new Map(g.connections).set(f.uid,{accounts:f.accounts??p.accounts,chainId:f.chainId??p.chainId,connector:p.connector})}:g})}function _(f){m.getState().status==="connecting"||m.getState().status==="reconnecting"||m.setState(g=>{const p=s.getState().find(C=>C.uid===f.uid);return p?(p.emitter.listenerCount("connect")&&p.emitter.off("connect",v),p.emitter.listenerCount("change")||p.emitter.on("change",v),p.emitter.listenerCount("disconnect")||p.emitter.on("disconnect",I),{...g,connections:new Map(g.connections).set(f.uid,{accounts:f.accounts,chainId:f.chainId,connector:p}),current:f.uid,status:"connected"}):g})}function I(f){m.setState(g=>{const p=g.connections.get(f.uid);if(p){const S=p.connector;S.emitter.listenerCount("change")&&p.connector.emitter.off("change",v),S.emitter.listenerCount("disconnect")&&p.connector.emitter.off("disconnect",I),S.emitter.listenerCount("connect")||p.connector.emitter.on("connect",_)}if(g.connections.delete(f.uid),g.connections.size===0)return{...g,connections:new Map,current:null,status:"disconnected"};const C=g.connections.values().next().value;return{...g,connections:new Map(g.connections),current:C.connector.uid}})}return{get chains(){return r.getState()},get connectors(){return s.getState()},storage:t,getClient:h,get state(){return m.getState()},setState(f){let g;typeof f=="function"?g=f(m.getState()):g=f;const p=w();typeof g!="object"&&(g=p),Object.keys(p).some(S=>!(S in g))&&(g=p),m.setState(g,!0)},subscribe(f,g,p){return m.subscribe(f,g,p?{...p,fireImmediately:p.emitImmediately}:void 0)},_internal:{mipd:n,store:m,ssr:!!u,syncConnectedChain:a,transports:o.transports,chains:{setState(f){const g=typeof f=="function"?f(r.getState()):f;if(g.length!==0)return r.setState(g,!0)},subscribe(f){return r.subscribe(f)}},connectors:{providerDetailToConnector:l,setup:c,setState(f){return s.setState(typeof f=="function"?f(s.getState()):f,!0)},subscribe(f){return s.subscribe(f)}},events:{change:v,connect:_,disconnect:I}}}}function j(e,i,t){const a=e[i.name];if(typeof a=="function")return a;const u=e[t];return typeof u=="function"?u:o=>i(e,o)}async function ue(e,i){var a;let t;if(typeof i.connector=="function"?t=e._internal.connectors.setup(i.connector):t=i.connector,t.uid===e.state.current)throw new Kt;try{e.setState(n=>({...n,status:"connecting"})),t.emitter.emit("message",{type:"connecting"});const u=await t.connect({chainId:i.chainId}),o=u.accounts;return t.emitter.off("connect",e._internal.events.connect),t.emitter.on("change",e._internal.events.change),t.emitter.on("disconnect",e._internal.events.disconnect),await((a=e.storage)==null?void 0:a.setItem("recentConnectorId",t.id)),e.setState(n=>({...n,connections:new Map(n.connections).set(t.uid,{accounts:o,chainId:u.chainId,connector:t}),current:t.uid,status:"connected"})),{accounts:o,chainId:u.chainId}}catch(u){throw e.setState(o=>({...o,status:o.current?"connected":"disconnected"})),u}}async function le(e,i={}){var u,o;let t;if(i.connector)t=i.connector;else{const{connections:n,current:r}=e.state,s=n.get(r);t=s==null?void 0:s.connector}const a=e.state.connections;t&&(await t.disconnect(),t.emitter.off("change",e._internal.events.change),t.emitter.off("disconnect",e._internal.events.disconnect),t.emitter.on("connect",e._internal.events.connect),a.delete(t.uid)),e.setState(n=>{if(a.size===0)return{...n,connections:new Map,current:null,status:"disconnected"};const r=a.values().next().value;return{...n,connections:new Map(a),current:r.connector.uid}});{const n=e.state.current;if(!n)return;const r=(u=e.state.connections.get(n))==null?void 0:u.connector;if(!r)return;await((o=e.storage)==null?void 0:o.setItem("recentConnectorId",r.id))}}async function Q(e,i={}){let t;if(i.connector){const{connector:s}=i,[c,l]=await Promise.all([s.getAccounts(),s.getChainId()]);t={accounts:c,chainId:l,connector:s}}else t=e.state.connections.get(e.state.current);if(!t)throw new Vt;const a=i.chainId??t.chainId,u=t.connector;if(u.getClient)return u.getClient({chainId:a});const o=vt(i.account??t.accounts[0]);o.address=M(o.address);const n=e.chains.find(s=>s.id===a),r=await t.connector.getProvider({chainId:a});if(i.account&&!t.accounts.some(s=>s.toLowerCase()===o.address.toLowerCase()))throw new Ht({address:o.address,connector:u});return st({account:o,chain:n,name:"Connector Client",transport:s=>Ct(r)({...s,retryCount:0})})}async function de(e,i){const{chainId:t,connector:a,...u}=i;let o;i.account?o=i.account:o=(await Q(e,{account:i.account,chainId:t,connector:a})).account;const n=e.getClient({chainId:t});return j(n,it,"estimateGas")({...u,account:o})}function ht(e){return typeof e=="number"?e:e==="wei"?0:Math.abs(It[e])}function Z(e){const i=e.state.current,t=e.state.connections.get(i),a=t==null?void 0:t.accounts,u=a==null?void 0:a[0],o=e.chains.find(r=>r.id===(t==null?void 0:t.chainId)),n=e.state.status;switch(n){case"connected":return{address:u,addresses:a,chain:o,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:n};case"reconnecting":return{address:u,addresses:a,chain:o,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!!u,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:n};case"connecting":return{address:u,addresses:a,chain:o,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:n};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:n}}}async function Yt(e,i){const{allowFailure:t=!0,chainId:a,contracts:u,...o}=i,n=e.getClient({chainId:a});return j(n,St,"multicall")({allowFailure:t,contracts:u,...o})}function te(e,i){const{chainId:t,...a}=i,u=e.getClient({chainId:t});return j(u,_t,"readContract")(a)}async function ee(e,i){const{allowFailure:t=!0,blockNumber:a,blockTag:u,...o}=i,n=i.contracts;try{const r=n.reduce((d,h,w)=>{const y=h.chainId??e.state.chainId;return{...d,[y]:[...d[y]||[],{contract:h,index:w}]}},{}),s=()=>Object.entries(r).map(([d,h])=>Yt(e,{...o,allowFailure:t,blockNumber:a,blockTag:u,chainId:parseInt(d),contracts:h.map(({contract:w})=>w)})),c=(await Promise.all(s())).flat(),l=Object.values(r).flatMap(d=>d.map(({index:h})=>h));return c.reduce((d,h,w)=>(d&&(d[l[w]]=h),d),[])}catch(r){if(r instanceof ct)throw r;const s=()=>n.map(c=>te(e,{...c,blockNumber:a,blockTag:u}));return t?(await Promise.allSettled(s())).map(c=>c.status==="fulfilled"?{result:c.value,status:"success"}:{error:c.reason,result:void 0,status:"failure"}):await Promise.all(s())}}async function he(e,i){const{address:t,blockNumber:a,blockTag:u,chainId:o,token:n,unit:r="ether"}=i;if(n)try{return nt(e,{balanceAddress:t,chainId:o,symbolType:"string",tokenAddress:n})}catch(h){if(h instanceof ct){const w=await nt(e,{balanceAddress:t,chainId:o,symbolType:"bytes32",tokenAddress:n}),y=ot(At(w.symbol,{dir:"right"}));return{...w,symbol:y}}throw h}const s=e.getClient({chainId:o}),l=await j(s,jt,"getBalance")(a?{address:t,blockNumber:a}:{address:t,blockTag:u}),d=e.chains.find(h=>h.id===o)??s.chain;return{decimals:d.nativeCurrency.decimals,formatted:rt(l,ht(r)),symbol:d.nativeCurrency.symbol,value:l}}async function nt(e,i){const{balanceAddress:t,chainId:a,symbolType:u,tokenAddress:o,unit:n}=i,r={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:u}]}],address:o},[s,c,l]=await ee(e,{allowFailure:!1,contracts:[{...r,functionName:"balanceOf",args:[t],chainId:a},{...r,functionName:"decimals",chainId:a},{...r,functionName:"symbol",chainId:a}]}),d=rt(s??"0",ht(n??c));return{decimals:c,formatted:d,symbol:l,value:s}}function H(e,i){if(e===i)return!0;if(e&&i&&typeof e=="object"&&typeof i=="object"){if(e.constructor!==i.constructor)return!1;let t,a;if(Array.isArray(e)&&Array.isArray(i)){if(t=e.length,t!==i.length)return!1;for(a=t;a--!==0;)if(!H(e[a],i[a]))return!1;return!0}if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===i.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===i.toString();const u=Object.keys(e);if(t=u.length,t!==Object.keys(i).length)return!1;for(a=t;a--!==0;)if(!Object.prototype.hasOwnProperty.call(i,u[a]))return!1;for(a=t;a--!==0;){const o=u[a];if(o&&!H(e[o],i[o]))return!1}return!0}return e!==e&&i!==i}function fe(e,i){const{chainId:t,...a}=i,u=e.getClient({chainId:t});return j(u,kt,"getEnsAvatar")(a)}function pe(e,i){const{chainId:t,...a}=i,u=e.getClient({chainId:t});return j(u,Mt,"getEnsName")(a)}async function ge(e,i){const{account:t,chainId:a,...u}=i,o=t??Z(e).address,n=e.getClient({chainId:a});return j(n,Ut,"prepareTransactionRequest")({...u,...o?{account:o}:{}})}let K=!1;async function we(e,i={}){var c,l;if(K)return[];K=!0,e.setState(d=>({...d,status:d.current?"reconnecting":"connecting"}));const t=[];if((c=i.connectors)!=null&&c.length)for(const d of i.connectors){let h;typeof d=="function"?h=e._internal.connectors.setup(d):h=d,t.push(h)}else t.push(...e.connectors);let a;try{a=await((l=e.storage)==null?void 0:l.getItem("recentConnectorId"))}catch{}const u={};for(const[,d]of e.state.connections)u[d.connector.id]=1;a&&(u[a]=0);const o=Object.keys(u).length>0?[...t].sort((d,h)=>(u[d.id]??10)-(u[h.id]??10)):t;let n=!1;const r=[],s=[];for(const d of o){const h=await d.getProvider();if(!h||s.some(b=>b===h)||!await d.isAuthorized())continue;const y=await d.connect({isReconnecting:!0}).catch(()=>null);y&&(d.emitter.off("connect",e._internal.events.connect),d.emitter.on("change",e._internal.events.change),d.emitter.on("disconnect",e._internal.events.disconnect),e.setState(b=>{const m=new Map(n?b.connections:new Map).set(d.uid,{accounts:y.accounts,chainId:y.chainId,connector:d});return{...b,current:n?b.current:d.uid,connections:m}}),r.push({accounts:y.accounts,chainId:y.chainId,connector:d}),s.push(h),n=!0)}return(e.state.status==="reconnecting"||e.state.status==="connecting")&&(n?e.setState(d=>({...d,status:"connected"})):e.setState(d=>({...d,connections:new Map,current:null,status:"disconnected"}))),K=!1,r}async function ye(e,i){const{account:t,chainId:a,connector:u,gas:o,...n}=i;let r;typeof t=="object"&&t.type==="local"?r=e.getClient({chainId:a}):r=await Q(e,{account:t,chainId:a,connector:u});const{connector:s}=Z(e),c=await(async()=>{var h;if(!(!("data"in i)||!i.data)&&!((h=u??s)!=null&&h.supportsSimulation)&&o!==null)return o===void 0?j(r,it,"estimateGas")({...n,account:t,chain:a?{id:a}:null}):o})();return await j(r,$t,"sendTransaction")({...n,...t?{account:t}:{},gas:c,chain:a?{id:a}:null})}async function me(e,i){const{account:t,connector:a,...u}=i;let o;return typeof t=="object"&&t.type==="local"?o=e.getClient():o=await Q(e,{account:t,connector:a}),j(o,qt,"signMessage")({...u,...t?{account:t}:{}})}async function be(e,i){var n;const{addEthereumChainParameter:t,chainId:a}=i,u=e.state.connections.get(((n=i.connector)==null?void 0:n.uid)??e.state.current);if(u){const r=u.connector;if(!r.switchChain)throw new Jt({connector:r});return await r.switchChain({addEthereumChainParameter:t,chainId:a})}const o=e.chains.find(r=>r.id===a);if(!o)throw new x;return e.setState(r=>({...r,chainId:a})),o}function ve(e,i){const{onChange:t}=i;return e.subscribe(()=>Z(e),t,{equalityFn(a,u){const{connector:o,...n}=a,{connector:r,...s}=u;return H(n,s)&&(o==null?void 0:o.id)===(r==null?void 0:r.id)&&(o==null?void 0:o.uid)===(r==null?void 0:r.uid)}})}function Ce(e,i){const{onChange:t}=i;return e._internal.connectors.subscribe((a,u)=>{t(Object.values(a),u)})}async function Ie(e,i){const{chainId:t,timeout:a=0,...u}=i,o=e.getClient({chainId:t}),r=await j(o,Nt,"waitForTransactionReceipt")({...u,timeout:a});if(r.status==="reverted"){const c=await j(o,Ot,"getTransaction")({hash:r.transactionHash}),d=await j(o,Rt,"call")({...c,gasPrice:c.type!=="eip1559"?c.gasPrice:void 0,maxFeePerGas:c.type==="eip1559"?c.maxFeePerGas:void 0,maxPriorityFeePerGas:c.type==="eip1559"?c.maxPriorityFeePerGas:void 0}),h=d!=null&&d.data?ot(`0x${d.data.substring(138)}`):"unknown reason";throw new Error(h)}return{...r,chainId:o.chain.id}}function Se(e){if(typeof e=="string")return Number.parseInt(e,e.trim().substring(0,2)==="0x"?16:10);if(typeof e=="bigint")return Number(e);if(typeof e=="number")return e;throw new Error(`Cannot normalize chainId "${e}" of type "${typeof e}"`)}ft.type="coinbaseWallet";function ft(e){let t,a,u,o,n;return r=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",supportsSimulation:!0,type:ft.type,async connect({chainId:s}={}){try{const c=await this.getProvider(),l=(await c.request({method:"eth_requestAccounts"})).map(h=>M(h));u||(u=this.onAccountsChanged.bind(this),c.on("accountsChanged",u)),o||(o=this.onChainChanged.bind(this),c.on("chainChanged",o)),n||(n=this.onDisconnect.bind(this),c.on("disconnect",n));let d=await this.getChainId();if(s&&d!==s){const h=await this.switchChain({chainId:s}).catch(w=>{if(w.code===A.code)throw w;return{id:d}});d=(h==null?void 0:h.id)??d}return{accounts:l,chainId:d}}catch(c){throw/(user closed modal|accounts received is empty|user denied account)/i.test(c.message)?new A(c):c}},async disconnect(){const s=await this.getProvider();u&&(s.removeListener("accountsChanged",u),u=void 0),o&&(s.removeListener("chainChanged",o),o=void 0),n&&(s.removeListener("disconnect",n),n=void 0),s.disconnect(),s.close()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(c=>M(c))},async getChainId(){const c=await(await this.getProvider()).request({method:"eth_chainId"});return Number(c)},async getProvider(){var s;if(!a){const{default:c}=await at(()=>import("./@coinbase-NHaBArST.js").then(b=>b.i),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]));let l;typeof c!="function"&&typeof c.default=="function"?l=c.default:l=c,t=new l({reloadOnDisconnect:!1,...e});const d=(s=t.walletExtension)==null?void 0:s.getChainId(),h=r.chains.find(b=>e.chainId?b.id===e.chainId:b.id===d)||r.chains[0],w=e.chainId||(h==null?void 0:h.id),y=e.jsonRpcUrl||(h==null?void 0:h.rpcUrls.default.http[0]);a=t.makeWeb3Provider(y,w)}return a},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:s,chainId:c}){var h,w,y,b;const l=r.chains.find(m=>m.id===c);if(!l)throw new R(new x);const d=await this.getProvider();try{return await d.request({method:"wallet_switchEthereumChain",params:[{chainId:D(l.id)}]}),l}catch(m){if(m.code===4902)try{let v;s!=null&&s.blockExplorerUrls?v=s.blockExplorerUrls:v=(h=l.blockExplorers)!=null&&h.default.url?[(w=l.blockExplorers)==null?void 0:w.default.url]:[];let _;(y=s==null?void 0:s.rpcUrls)!=null&&y.length?_=s.rpcUrls:_=[((b=l.rpcUrls.default)==null?void 0:b.http[0])??""];const I={blockExplorerUrls:v,chainId:D(c),chainName:(s==null?void 0:s.chainName)??l.name,iconUrls:s==null?void 0:s.iconUrls,nativeCurrency:(s==null?void 0:s.nativeCurrency)??l.nativeCurrency,rpcUrls:_};return await d.request({method:"wallet_addEthereumChain",params:[I]}),l}catch(v){throw new A(v)}throw new R(m)}},onAccountsChanged(s){s.length===0?this.onDisconnect():r.emitter.emit("change",{accounts:s.map(c=>M(c))})},onChainChanged(s){const c=Number(s);r.emitter.emit("change",{chainId:c})},async onDisconnect(s){r.emitter.emit("disconnect");const c=await this.getProvider();u&&(c.removeListener("accountsChanged",u),u=void 0),o&&(c.removeListener("chainChanged",o),o=void 0),n&&(c.removeListener("disconnect",n),n=void 0)}})}pt.type="walletConnect";function pt(e){const i=e.isNewChainsStale??!0;let t,a;const u="eip155";return o=>({id:"walletConnect",name:"WalletConnect",type:pt.type,async setup(){const n=await this.getProvider().catch(()=>null);n&&(n.on("connect",this.onConnect.bind(this)),n.on("session_delete",this.onSessionDelete.bind(this)))},async connect({chainId:n,...r}={}){var s,c;try{const l=await this.getProvider();if(!l)throw new N;l.on("display_uri",this.onDisplayUri);let d=n;if(!d){const b=await((s=o.storage)==null?void 0:s.getItem("state"))??{};o.chains.some(v=>v.id===b.chainId)?d=b.chainId:d=(c=o.chains[0])==null?void 0:c.id}if(!d)throw new Error("No chains found on connector.");const h=await this.isChainsStale();if(l.session&&h&&await l.disconnect(),!l.session||h){const b=o.chains.filter(m=>m.id!==d).map(m=>m.id);await l.connect({optionalChains:[d,...b],..."pairingTopic"in r?{pairingTopic:r.pairingTopic}:{}}),this.setRequestedChainsIds(o.chains.map(m=>m.id))}const w=(await l.enable()).map(b=>M(b)),y=await this.getChainId();return l.removeListener("display_uri",this.onDisplayUri),l.removeListener("connect",this.onConnect.bind(this)),l.on("accountsChanged",this.onAccountsChanged.bind(this)),l.on("chainChanged",this.onChainChanged),l.on("disconnect",this.onDisconnect.bind(this)),l.on("session_delete",this.onSessionDelete.bind(this)),{accounts:w,chainId:y}}catch(l){throw/(user rejected|connection request reset)/i.test(l==null?void 0:l.message)?new A(l):l}},async disconnect(){const n=await this.getProvider();try{await(n==null?void 0:n.disconnect())}catch(r){if(!/No matching key/i.test(r.message))throw r}finally{n==null||n.removeListener("accountsChanged",this.onAccountsChanged.bind(this)),n==null||n.removeListener("chainChanged",this.onChainChanged),n==null||n.removeListener("disconnect",this.onDisconnect.bind(this)),n==null||n.removeListener("session_delete",this.onSessionDelete.bind(this)),n==null||n.on("connect",this.onConnect.bind(this)),this.setRequestedChainsIds([])}},async getAccounts(){return(await this.getProvider()).accounts.map(r=>M(r))},async getProvider({chainId:n}={}){var s;async function r(){const c=o.chains.map(d=>d.id);if(!c.length)return;const{EthereumProvider:l}=await at(()=>import("./@walletconnect-DbPiUmHX.js"),__vite__mapDeps([32,3,1,33,14,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,4,63]));return await l.init({...e,disableProviderPing:!0,optionalChains:c,projectId:e.projectId,rpcMap:Object.fromEntries(o.chains.map(d=>[d.id,d.rpcUrls.default.http[0]])),showQrModal:e.showQrModal??!0})}return t||(a||(a=r()),t=await a,t==null||t.events.setMaxListeners(1/0)),n&&await((s=this.switchChain)==null?void 0:s.call(this,{chainId:n})),t},async getChainId(){return(await this.getProvider()).chainId},async isAuthorized(){try{const[n,r]=await Promise.all([this.getAccounts(),this.getProvider()]);return n.length?await this.isChainsStale()&&r.session?(await r.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:n,chainId:r}){var c,l,d;const s=o.chains.find(h=>h.id===r);if(!s)throw new R(new x);try{const h=await this.getProvider(),w=this.getNamespaceChainsIds(),y=this.getNamespaceMethods();if(!w.includes(r)&&y.includes("wallet_addEthereumChain")){let m;n!=null&&n.blockExplorerUrls?m=n.blockExplorerUrls:m=(c=s.blockExplorers)!=null&&c.default.url?[(l=s.blockExplorers)==null?void 0:l.default.url]:[];let v;(d=n==null?void 0:n.rpcUrls)!=null&&d.length?v=n.rpcUrls:v=[...s.rpcUrls.default.http];const _={blockExplorerUrls:m,chainId:D(r),chainName:(n==null?void 0:n.chainName)??s.name,iconUrls:n==null?void 0:n.iconUrls,nativeCurrency:(n==null?void 0:n.nativeCurrency)??s.nativeCurrency,rpcUrls:v};await h.request({method:"wallet_addEthereumChain",params:[_]});const I=await this.getRequestedChainsIds();this.setRequestedChainsIds([...I,r])}return await h.request({method:"wallet_switchEthereumChain",params:[{chainId:D(r)}]}),s}catch(h){const w=typeof h=="string"?h:h==null?void 0:h.message;throw/user rejected request/i.test(w)?new A(h):new R(h)}},onAccountsChanged(n){n.length===0?this.onDisconnect():o.emitter.emit("change",{accounts:n.map(r=>M(r))})},onChainChanged(n){const r=Number(n);o.emitter.emit("change",{chainId:r})},async onConnect(n){const r=Number(n.chainId),s=await this.getAccounts();o.emitter.emit("connect",{accounts:s,chainId:r})},async onDisconnect(n){this.setRequestedChainsIds([]),o.emitter.emit("disconnect");const r=await this.getProvider();r.removeListener("accountsChanged",this.onAccountsChanged.bind(this)),r.removeListener("chainChanged",this.onChainChanged),r.removeListener("disconnect",this.onDisconnect.bind(this)),r.removeListener("session_delete",this.onSessionDelete.bind(this)),r.on("connect",this.onConnect.bind(this))},onDisplayUri(n){o.emitter.emit("message",{type:"display_uri",data:n})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){var r,s,c;return t?((c=(s=(r=t.session)==null?void 0:r.namespaces[u])==null?void 0:s.chains)==null?void 0:c.map(l=>parseInt(l.split(":")[1]||"")))??[]:[]},getNamespaceMethods(){var r,s;return t?((s=(r=t.session)==null?void 0:r.namespaces[u])==null?void 0:s.methods)??[]:[]},async getRequestedChainsIds(){var n;return await((n=o.storage)==null?void 0:n.getItem(this.requestedChainsStorageKey))??[]},async isChainsStale(){if(this.getNamespaceMethods().includes("wallet_addEthereumChain")||!i)return!1;const r=o.chains.map(l=>l.id),s=this.getNamespaceChainsIds();if(s.length&&!s.some(l=>r.includes(l)))return!1;const c=await this.getRequestedChainsIds();return!r.every(l=>c.includes(l))},async setRequestedChainsIds(n){var r;await((r=o.storage)==null?void 0:r.setItem(this.requestedChainsStorageKey,n))},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}})}export{at as _,ve as a,fe as b,he as c,ue as d,le as e,me as f,pe as g,de as h,Z as i,ye as j,Ie as k,re as l,pt as m,Se as n,J as o,ge as p,ft as q,ae as r,be as s,we as t,Ce as w};
