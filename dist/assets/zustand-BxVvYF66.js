var _={VITE_SIGNUP_BASE_URL:"https://www.app.gtxstream.com/signup",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const E=u=>(o,i,n)=>{const l=n.subscribe;return n.subscribe=(v,d,c)=>{let a=v;if(d){const h=(c==null?void 0:c.equalityFn)||Object.is;let f=v(n.getState());a=y=>{const S=v(y);if(!h(f,S)){const b=f;d(f=S,b)}},c!=null&&c.fireImmediately&&d(f,f)}return l(a)},u(o,i,n)},O=E;function w(u,o){let i;try{i=u()}catch{return}return{getItem:l=>{var e;const v=c=>c===null?null:JSON.parse(c,o==null?void 0:o.reviver),d=(e=i.getItem(l))!=null?e:null;return d instanceof Promise?d.then(v):v(d)},setItem:(l,e)=>i.setItem(l,JSON.stringify(e,o==null?void 0:o.replacer)),removeItem:l=>i.removeItem(l)}}const p=u=>o=>{try{const i=u(o);return i instanceof Promise?i:{then(n){return p(n)(i)},catch(n){return this}}}catch(i){return{then(n){return this},catch(n){return p(n)(i)}}}},R=(u,o)=>(i,n,l)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:r=>r,version:0,merge:(r,m)=>({...m,...r}),...o},v=!1;const d=new Set,c=new Set;let a;try{a=e.getStorage()}catch{}if(!a)return u((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),i(...r)},n,l);const h=p(e.serialize),f=()=>{const r=e.partialize({...n()});let m;const t=h({state:r,version:e.version}).then(g=>a.setItem(e.name,g)).catch(g=>{m=g});if(m)throw m;return t},y=l.setState;l.setState=(r,m)=>{y(r,m),f()};const S=u((...r)=>{i(...r),f()},n,l);let b;const s=()=>{var r;if(!a)return;v=!1,d.forEach(t=>t(n()));const m=((r=e.onRehydrateStorage)==null?void 0:r.call(e,n()))||void 0;return p(a.getItem.bind(a))(e.name).then(t=>{if(t)return e.deserialize(t)}).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var g;return b=e.merge(t,(g=n())!=null?g:S),i(b,!0),f()}).then(()=>{m==null||m(b,void 0),v=!0,c.forEach(t=>t(b))}).catch(t=>{m==null||m(void 0,t)})};return l.persist={setOptions:r=>{e={...e,...r},r.getStorage&&(a=r.getStorage())},clearStorage:()=>{a==null||a.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>s(),hasHydrated:()=>v,onHydrate:r=>(d.add(r),()=>{d.delete(r)}),onFinishHydration:r=>(c.add(r),()=>{c.delete(r)})},s(),b||S},H=(u,o)=>(i,n,l)=>{let e={storage:w(()=>localStorage),partialize:s=>s,version:0,merge:(s,r)=>({...r,...s}),...o},v=!1;const d=new Set,c=new Set;let a=e.storage;if(!a)return u((...s)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),i(...s)},n,l);const h=()=>{const s=e.partialize({...n()});return a.setItem(e.name,{state:s,version:e.version})},f=l.setState;l.setState=(s,r)=>{f(s,r),h()};const y=u((...s)=>{i(...s),h()},n,l);let S;const b=()=>{var s,r;if(!a)return;v=!1,d.forEach(t=>{var g;return t((g=n())!=null?g:y)});const m=((r=e.onRehydrateStorage)==null?void 0:r.call(e,(s=n())!=null?s:y))||void 0;return p(a.getItem.bind(a))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var g;return S=e.merge(t,(g=n())!=null?g:y),i(S,!0),h()}).then(()=>{m==null||m(S,void 0),S=n(),v=!0,c.forEach(t=>t(S))}).catch(t=>{m==null||m(void 0,t)})};return l.persist={setOptions:s=>{e={...e,...s},s.storage&&(a=s.storage)},clearStorage:()=>{a==null||a.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>b(),hasHydrated:()=>v,onHydrate:s=>(d.add(s),()=>{d.delete(s)}),onFinishHydration:s=>(c.add(s),()=>{c.delete(s)})},e.skipHydration||b(),S||y},D=(u,o)=>"getStorage"in o||"serialize"in o||"deserialize"in o?((_?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),R(u,o)):H(u,o),P=D;var U={VITE_SIGNUP_BASE_URL:"https://www.app.gtxstream.com/signup",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const I=u=>{let o;const i=new Set,n=(c,a)=>{const h=typeof c=="function"?c(o):c;if(!Object.is(h,o)){const f=o;o=a??typeof h!="object"?h:Object.assign({},o,h),i.forEach(y=>y(o,f))}},l=()=>o,d={setState:n,getState:l,subscribe:c=>(i.add(c),()=>i.delete(c)),destroy:()=>{(U?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),i.clear()}};return o=u(n,l,d),d},F=u=>u?I(u):I;export{F as c,P as p,O as s};
